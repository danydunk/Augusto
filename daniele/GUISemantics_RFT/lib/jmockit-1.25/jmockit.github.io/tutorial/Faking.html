<!DOCTYPE html>
<!--
  ~ Copyright (c) 2006 RogÃ©rio Liesenfeld
  ~ This file is subject to the terms of the MIT license (see LICENSE.txt).
  -->
<html>
<head>
   <title>JMockit - Tutorial - Faking</title>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <link rel="stylesheet" type="text/css" href="../prettify.css"/>
   <link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"/>
   <script type="text/javascript" src="../highlight.pack.js"></script>
   <script type="text/javascript">hljs.initHighlightingOnLoad()</script>
</head>
<body>
<h1 class="header">
   <a href="../index.html">JMockit</a>
   <span>An automated testing toolkit for Java</span>
   <span class="navigation">
      <a href="Mocking.html"><img src="go-previous.png" title="Previous chapter"></a>
      <a href="CodeCoverage.html"><img src="go-next.png" title="Next chapter"></a>
      <a href="../tutorial.html"><img src="go-home.png" title="Contents"></a>
   </span>
</h1>
<h1 id="top">
   <a href="#">Faking</a>
</h1>
<ol class="contents">
   <li><a href="#mocks">Mock methods and mock classes</a></li>
   <li>
      <a href="#setUp">Applying mock-ups for a test</a>
      <ol>
         <li><a href="#mockableMethods">Kinds of methods which can be faked</a></li>
         <li><a href="#inline">In-line mock classes</a></li>
      </ol>
   </li>
   <li><a href="#interfaces">Faking an interface</a></li>
   <li><a href="#implementationClasses">Faking unspecified implementation classes</a></li>
   <li><a href="#constraints">Invocation count constraints</a></li>
   <li><a href="#initializers">Faking class initializers</a></li>
   <li><a href="#invocation">Accessing the invocation context</a></li>
   <li><a href="#proceed">Proceeding into the real implementation</a></li>
   <li>
      <a href="#reuse">Reusing mock-ups between tests</a>
      <ol>
         <li><a href="#beforeAfter">Using before/after methods</a></li>
         <li><a href="#reusableMocks">Reusable mock classes</a></li>
      </ol>
   </li>
   <li><a href="#widerScopes">Mock-ups at the test class/suite level</a></li>
   <li><a href="#advice">Applying AOP-style advice</a></li>
</ol>
<div style="text-align: center;" title="Click on types to open API documentation">
   <map name="figure1">
      <area shape="rect" coords="1,1,131,34" href="../api1x/mockit/MockUp.html">
      <area shape="rect" coords="138,1,215,34" href="../api1x/mockit/Mock.html">
      <area shape="rect" coords="222,1,342,34" href="../api1x/mockit/Invocation.html">
   </map>
   <img src="FakingAPI.png" usemap="#figure1">
</div>
<p>
   In the JMockit toolkit, the <strong>Mockups API</strong> provides support for the creation of <em>fake</em>
   implementations, or "<em>mock-ups</em>".
   Typically, a mock-up targets a few methods and/or constructors in the class to be faked, while leaving most other
   methods and constructors unmodified.
</p>
<p>
   Fake implementations can be particularly useful in <em>integration</em> tests which depend on external entities or
   resources such as the network, the file system, etc.
   The replacement of real implementations with fake ones is completely transparent to the code which uses those
   dependencies, and can be switched on and off for the scope of a single test, all tests in a single test class, or
   even for the entire test run.
</p>
<p>
   For the remaining of this chapter, lets say we want to write tests for an application that uses the
   <a href="http://download.oracle.com/javase/7/docs/api/javax/security/auth/login/LoginContext.html">
      javax.security.auth.login.LoginContext</a> class (from the standard JAAS API) in order to authenticate users.
   In this case, we don't want our tests to actually execute any of the real JAAS code, since it may depend on external
   configuration and might not easily work in a developer testing environment.
   Therefore, an application class depending on <code class="type">LoginContext</code> will be the "code under test",
   while the <code class="type">LoginContext</code> class (the dependency) will have at least some of its methods and
   constructors faked for any given test which involves authentication logic.
</p>

<h2 id="mocks">
   <a href="#mocks">Mock methods and mock classes</a>
</h2>
<p>
   In the context of the Mockups API, a <em>mock (or fake) method</em> is any method in a <em>mock (fake) class</em>
   that gets annotated with <code class="annotation">@Mock</code>.
   For short, in this chapter we refer to annotated mock methods simply as "mocks"; in other contexts, the word "mock"
   may refer to an <em>instance</em> of a mocked class instead.
   A <em>mock class</em> is any class extending the <code class="type">mockit.MockUp&lt;T></code> generic base class,
   where <code>&lt;T></code> is the type to be mocked up.
   The example below shows several mocks defined in a mock class for our example "real" class,
   <code class="type">javax.security.auth.login.LoginContext</code>.
</p>
<pre><code>public final class MockLoginContext extends MockUp&lt;LoginContext>
{
   @Mock
   public void $init(String name, CallbackHandler callbackHandler)
   {
      assertEquals("test", name);
      assertNotNull(callbackHandler);
   }

   @Mock
   public void login() {}

   @Mock
   public Subject getSubject() { return null; }
}
</code></pre>
<p>
   When a mock class is applied to a real class, the latter gets the implementation of those methods and constructors
   which have corresponding mocks temporarily replaced with the implementations of the matching mock methods, as
   defined in the mock class.
   In other words, the real class becomes "mocked-up" (or "faked") for the duration of the test which applied the mock
   class, and will respond accordingly whenever it receives invocations during test execution.
   At runtime, what really happens is that the execution of a mocked method/constructor is intercepted and redirected to
   the corresponding mock method, which then executes and returns (unless an exception/error is thrown) to the original
   caller, without this one noticing that a different method was actually executed.
   Normally, the "caller" class is the one under test, while the mocked class is a dependency.
</p>
<p>
   Mock classes are often defined as nested (<code>static</code>), inner (non-<code>static</code>), or even as
   <em>anonymous</em> classes inside a JUnit/TestNG test class.
   There is nothing preventing mock classes from being top-level, though.
   That would be useful if the mock class is to be reused in multiple test classes.
</p>
<p>
   Each <code class="annotation">@Mock</code> method must have a corresponding "real method/constructor" with the
   <em>same signature</em> in the targeted real class.
   For a mocked <em>method</em>, the signature consists of the method name and parameters; for a mocked
   <em>constructor</em>, it's just the parameters, with the mock method having the special name "<code>$init</code>".
   If a matching real method/constructor cannot be found for a given mock method, either in the specified real class or
   in its super-classes (excluding <code class="type">java.lang.Object</code>), an
   <code class="type">IllegalArgumentException</code> is thrown when the test attempts to apply the mock class.
   Notice this exception can be caused by a refactoring in the real class (such as renaming the real method), so it's
   important to understand why it happens.
</p>
<p>
   Finally, notice there is no need to have mocks for <em>all</em> methods and constructors in a real class.
   Any such method or constructor for which no corresponding mock exists in the mock class will simply stay "as is",
   that is, it won't be mocked.
   This, of course, assuming there isn't some <em>other</em> mock class applied by the same test to the same real class,
   something which is perfectly valid (and sometimes useful).
   If two (or more) mock classes happen to be applied to the same real class for the same test, then such mock classes
   should avoid defining the same mock twice.
   In case a mock <em>is</em> duplicated, though, the "last" one to be applied wins.
</p>

<h2 id="setUp">
   <a href="#setUp">Applying mock-ups for a test</a>
</h2>
<p>
   A given mock class must be applied to a corresponding real class to have any effect.
   This is usually done inside an individual test method or inside a <code class="annotation">@BeforeMethod</code>
   (TestNG) or <code class="annotation">@Before</code> (JUnit 4) method.
   Once a mock class is applied, all executions of the mocked methods and constructors of the real class get
   automatically redirected to the corresponding mock methods.
</p>
<p>
   To apply the <code class="type">MockLoginContext</code> mock class above, we simply instantiate it:
</p>
<pre><code>@Test
public void applyingAMockClass() throws Exception
{
   <strong>new MockLoginContext()</strong>);

   // Inside an application class which creates a suitable <span class="type">CallbackHandler</span>:
   new LoginContext("test", callbackHandler).login();

   ...
}
</code></pre>
<p>
   Since the mock class is applied inside a test method, the faking of <code class="type">LoginContext</code> by
   <code class="type">MockLoginContext</code> will be in effect only for that particular test.
</p>
<p>
   When the constructor invocation that instantiates <code class="type">LoginContext</code> executes, the corresponding
   "<code>$init</code>" mock method in <code class="type">MockLoginContext</code> will be executed, asserting the
   validity of the invocation arguments.
   Similarly, when the <code>LoginContext#login</code> method is called, the corresponding mock method will be executed,
   which in this case will do nothing since the method has no parameters and <code>void</code> return type.
   The mock class instance on which these invocations occur is the one created in the first part of the test.
</p>
<p>
   The (partial) example test above simply verifies that the <code class="type">LoginContext</code> class is
   instantiated with valid arguments through a particular constructor that takes a context name and a callback handler.
   If the real class is not instantiated at all, the test would still pass (unless some other condition causes it to
   fail).
   The invocation of the <code>login</code> method also has no effect on the outcome of this test, except for the fact
   that such an invocation will result in the execution of an empty mock method instead of the real method.
</p>
<p>
   Now, what if we wanted to simulate an authentication failure for a different test?
   The <code>LoginContext#login()</code> method declares that it can throw a <code class="type">LoginException</code>
   "if the authentication fails", so what we need to do is very simple (using JUnit 4 in this example):
</p>
<pre><code>public static class MockLoginContextThatFailsAuthentication extends MockUp&lt;LoginContext>
{
   @Mock
   public void $init(String name) {}

   @Mock
   public void login() throws LoginException
   {
      throw new LoginException();
   }
}

@Test(expected = LoginException.class)
public void settingUpAnotherMockClass() throws Exception
{
   new <strong>MockLoginContextThatFailsAuthentication</strong>();

   // Inside an application class:
   new LoginContext("test").login();
}
</code></pre>
<p>
   This test will only pass if the <code>LoginContext#login()</code> method throws an exception, which it will when the
   corresponding mock method is executed.
</p>

<h3 id="mockableMethods">
   <a href="#mockableMethods">Kinds of methods which can be faked</a>
</h3>
<p>
   So far, we have only faked public instance methods with public instance mock methods.
   In reality, any other kind of method in a real class can be faked: methods with <code>private</code>,
   <code>protected</code> or "package-private" accessibility, <code>static</code> methods, <code>final</code> methods,
   and <code>native</code> methods.
   Even more, a <code>static</code> method in the real class can be faked by an <em>instance</em> mock method, and
   vice-versa (an instance real method with a <code>static</code> mock).
</p>
<p>
   Methods to be faked need to have an implementation, though not necessarily in bytecode (in the case of
   <code>native</code> methods).
   Therefore, an <code>abstract</code> method cannot be faked directly, and the same applies to the methods of a Java
   <code>interface</code>.
   (That said, as shown later the Mockups API can automatically create a proxy class that implements an interface.)
</p>

<h3 id="inline">
   <a href="#inline">In-line mock classes</a>
</h3>
<p>
   Sometimes, we need to fake a class only for a single test.
   In such a situation we can create an <em>anonymous mock class</em> inside an individual test method, as demonstrated
   by the next example.
</p>
<pre><code>@Test
public void settingUpMocksUsingAnAnonymousMockClass() throws Exception
{
   new MockUp&lt;LoginContext>() {
      @Mock void $init(String name) { assertEquals("test", name); }
      @Mock void login() {}
   });

   new LoginContext("test").login();
}
</code></pre>
<p>
   Note that mock methods don't need to be <code>public</code>.
</p>

<h2 id="interfaces">
   <a href="#interfaces">Faking an interface</a>
</h2>
<p>
   Most of the time a mock class targets a real class directly.
   But what if we need a mock object that implements a certain interface, to be passed to code under test?
   The following example test shows how it is done for the interface
   <a href="http://download.oracle.com/javase/7/docs/api/javax/security/auth/callback/CallbackHandler.html">
      javax.security.auth.callback.CallbackHandler</a>.
</p>
<pre><code>@Test
public void fakingAnInterface() throws Exception
{
   CallbackHandler callbackHandler = new MockUp&lt;CallbackHandler>() {
      @Mock
      void handle(Callback[] callbacks)
      {
         assertEquals(1, callbacks.length);
         assertTrue(callbacks[0] instanceof NameCallback);
      }
   }<strong>.getMockInstance()</strong>;

   callbackHandler.handle(new Callback[] {new NameCallback("Enter name:")});
}
</code></pre>
<p>
   The <a href="../api1x/mockit/MockUp.html#getMockInstance()"><code>MockUp#getMockInstance()</code></a> method returns
   a proxy object that implements the desired interface.
</p>

<h2 id="implementationClasses">
   <a href="#implementationClasses">Faking unspecified implementation classes</a>
</h2>
<p>
   To demonstrate this feature, lets consider the following code under test.
</p>
<pre><code>public interface Service { int doSomething(); }
final class ServiceImpl implements Service { public int doSomething() { return 1; } }

public final class TestedUnit
{
   private final Service service1 = <strong>new ServiceImpl();</strong>
   private final Service service2 = <strong>new Service() { public int doSomething() { return 2; } };</strong>

   public int businessOperation()
   {
      return service1.doSomething() + service2.doSomething();
   }
}
</code></pre>
<p>
   The method we want to test, <code>businessOperation()</code>, uses classes that implement a separate interface,
   <code class="type">Service</code>.
   One of these implementations is defined through an anonymous inner class, which is completely inaccessible (except
   for the use of Reflection) from client code.
</p>
<p>
   Given a base type (be it an <code>interface</code>, an <code>abstract</code> class, or any sort of base class), we
   can write a test which only knows about the base type but where all implementing/extending implementation classes get
   faked.
   To do so, we create a mock-up whose mocked type refers only to the known base type, and does so through a
   <em>type variable</em>.
   Not only will implementation classes already loaded by the JVM get faked, but also any additional classes that
   happen to get loaded by the JVM during later test execution.
   This ability is demonstrated below.
</p>
<pre><code>@Test
public <strong>&lt;T extends Service></strong> void fakingImplementationClassesFromAGivenBaseType()
{
   new MockUp<strong>&lt;T></strong>() {
      @Mock int doSomething() { return 7; }
   };

   int result = new TestedUnit().businessOperation();

   assertEquals(14, result);
}
</code></pre>
<p>
   In the test above, all invocations to methods implementing <code>Service#doSomething()</code> will be redirected to
   the mock method implementation, regardless of the actual class implementing the interface method.
</p>

<h2 id="constraints">
   <a href="#constraints">Invocation count constraints</a>
</h2>
<p>
   All example tests shown so far only used JUnit/TestNG "asserts" to verify invocation arguments.
   Sometimes, though, we may want to verify if a given method/constructor in a dependency is invoked at all by the code
   under test.
   We may also want to verify exactly how many invocations a given mock method received during the execution of a test,
   or specify that the test should fail if more/less than a certain number of invocations occurs.
   For this, we can specify <em>declarative constraints</em> on the <em>invocation count</em> of a given mock method, as
   the following example shows.
</p>
<pre><code>@Test
public void specifyingInvocationCountConstraints() throws Exception
{
   new MockUp&lt;LoginContext>() {
      @Mock(<strong>minInvocations = 1</strong>)
      void $init(String name) { assertEquals("test", name); }

      @Mock(<strong>invocations = 1</strong>)
      void login() {}

      @Mock(<strong>maxInvocations = 1</strong>)
      void logout() {}
   });

   new LoginContext("test").login();
}
</code></pre>
<p>
   In this test we used all three attributes of the <code class="annotation">@Mock</code> annotation related to
   invocation counts.
   The first mock method specifies that the <code>LoginContext(String)</code> constructor must be invoked
   <em>at least once</em> during the test.
   The second one specifies that the <code>login()</code> method must be invoked <em>exactly once</em>, while the third
   declares that <code>logout()</code> <em>can</em> be invoked, but not more than once.
</p>
<p>
   It is also valid to specify both <code>minInvocations</code> and <code>maxInvocations</code> on
   the same mock method, in order to constrain the invocation count to a given range.
</p>

<h2 id="initializers">
   <a href="#initializers">Faking class initializers</a>
</h2>
<p>
   When a class performs some work in one or more <em>static initialization blocks</em>, we may need to stub it out so
   it doesn't interfere with test execution.
   We can define a special mock method for that, as shown below.
</p>
<pre><code>@Test
public void fakingStaticInitializers()
{
   new MockUp&lt;ClassWithStaticInitializers>() {
      @Mock
      <strong>void $clinit()</strong>
      {
         // Do nothing here (usually).
      }
   };

   ClassWithStaticInitializers.doSomething();
}
</code></pre>
<p>
   Special care must be taken when the static initialization code of a class is faked.
   Note that this includes not only any "<code>static</code>" blocks in the class, but also any assignments to
   <code>static</code> fields (excluding those resolved at compile time, which do not produce executable bytecode).
   Since the JVM only attempts to initialize a class <em>once</em>, restoring the static initialization code of a
   faked class will have no effect.
   So, if you fake away the static initialization of a class that hasn't been initialized by the JVM yet, the original
   class initialization code will <em>never</em> be executed in the test run.
   This will cause any static fields that are assigned with expressions computed at runtime to instead remain
   initialized with the <em>default</em> values for their types.
</p>

<h2 id="invocation">
   <a href="#invocation">Accessing the invocation context</a>
</h2>
<p>
   A mock method can optionally declare an extra parameter of type <code class="type">mockit.Invocation</code>, provided
   it is the <em>first</em> parameter.
   For each actual invocation to the corresponding mocked method/constructor, an <code class="type">Invocation</code>
   object will be automatically passed in when the mock method is executed.
</p>
<p>
   This invocation context object provides several "getters" which can be used inside the mock method.
   One is the <code>getInvokedInstance()</code> method, which returns the <em>mocked</em> instance on which the
   invocation occurred (<code>null</code> if the mocked method is <code>static</code>).
   Other getters provide the number of invocations (including the current one) to the mocked method/constructor,
   the invocation count constraints (if any) as specified in the <code class="annotation">@Mock</code> annotation, etc.
   Below we have an example test.
</p>
<pre><code>@Test
public void accessingTheMockedInstanceInMockMethods() throws Exception
{
   final Subject testSubject = new Subject();

   new MockUp&lt;LoginContext>() {
      @Mock
      void $init(<strong>Invocation invocation</strong>, String name, Subject subject)
      {
         assertNotNull(name);
         assertSame(testSubject, subject);

         // Gets the invoked instance.
         LoginContext loginContext = <strong>invocation.getInvokedInstance()</strong>;

         // Verifies that this is the first invocation.
         assertEquals(1, invocation.getInvocationCount());

         // Forces setting of private Subject field, since no setter is available.
         Deencapsulation.setField(loginContext, subject);
      }

      @Mock(minInvocations = 1)
      void login(Invocation invocation)
      {
         // Gets the invoked instance.
         LoginContext loginContext = invocation.getInvokedInstance();

         // getSubject() returns null until the subject is authenticated.
         assertNull(loginContext.getSubject());

         // Private field set to true when login succeeds.
         Deencapsulation.setField(loginContext, "loginSucceeded", true);
      }

      @Mock
      void logout(Invocation invocation)
      {
         // Gets the invoked instance.
         LoginContext loginContext = invocation.getInvokedInstance();

         assertSame(testSubject, loginContext.getSubject());
      }
   };

   LoginContext theMockedInstance = new LoginContext("test", testSubject);
   theMockedInstance.login();
   theMockedInstance.logout();
}
</code></pre>

<h2 id="proceed">
   <a href="#proceed">Proceeding into the real implementation</a>
</h2>
<p>
   Once a <code class="annotation">@Mock</code> method is executing, any additional calls to the corresponding mocked
   method are also redirected to the mock method, causing its implementation to be re-entered.
   If, however, we want to execute the real implementation of the mocked method, we can call the <code>proceed()</code>
   method on the <code class="type">Invocation</code> object received as the first parameter to the mock method.
</p>
<p>
   The example test below exercises a <code class="type">LoginContext</code> object created normally (without any
   mocking in effect at creation time), using an unspecified <code>configuration</code>.
   (For the complete version of the test, see the
   <a href="http://github.com/jmockit/jmockit1/blob/master/main/test/mockit/MockAnnotationsTest.java">
      <code>mockit.MockAnnotationsTest</code></a> class.)
</p>
<pre><code>@Test
public void proceedIntoRealImplementationsOfMockedMethods() throws Exception
{
   // Create objects to be exercised by the code under test:
   LoginContext loginContext = new LoginContext("test", null, null, configuration);

   // Set up mocks:
   ProceedingMockLoginContext mockInstance = new ProceedingMockLoginContext();

   // Exercise the code under test:
   assertNull(loginContext.getSubject());
   <strong>loginContext.login();</strong>
   assertNotNull(loginContext.getSubject());
   assertTrue(mockInstance.loggedIn);

   mockInstance.ignoreLogout = true;
   <strong>loginContext.logout();</strong> // first entry: do nothing
   assertTrue(mockInstance.loggedIn);

   mockInstance.ignoreLogout = false;
   <strong>loginContext.logout();</strong> // second entry: execute real implementation
   assertFalse(mockInstance.loggedIn);
}

static final class ProceedingMockLoginContext extends MockUp&lt;LoginContext>
{
   boolean ignoreLogout;
   boolean loggedIn;

   @Mock
   void login(Invocation inv) throws LoginException
   {
      try {
         <strong>inv.proceed();</strong> // executes the real code of the mocked method
         loggedIn = true;
      }
      finally {
         // This is here just to show that arbitrary actions can be taken inside
         // the mock, <em>before</em> and/or <em>after</em> the real method gets executed.
         LoginContext lc = inv.getInvokedInstance();
         System.out.println("Login attempted for " + lc.getSubject());
      }
   }

   @Mock
   void logout(Invocation inv) throws LoginException
   {
      // We can choose to proceed into the real implementation <em>or not</em>.
      if (!ignoreLogout) {
         <strong>inv.proceed();</strong>
         loggedIn = false;
      }
   }
}
</code></pre>
<p>
   In the example above, <em>all</em> the code inside the tested <code class="type">LoginContext</code> class will get
   executed, even though some methods (<code>login</code> and <code>logout</code>) are mocked.
   This example is contrived; in practice, the ability to proceed into real implementations would not normally be useful
   for <em>testing</em> per se, not directly at least.
</p>
<p>
   You may have noticed that use of <code>Invocation#proceed(...)</code> in a mock method effectively behaves like
   <em>advice</em> (from AOP jargon) for the corresponding real method.
   This is a powerful ability that can be useful for certain things (think of an interceptor or decorator).
</p>
<p>
   For more details on all the methods available in the <code class="type">mockit.Invocation</code> class, see its
   <a href="../api1x/mockit/Invocation.html">API documentation</a>.
</p>

<h2 id="reuse">
   <a href="#reuse">Reusing mock-ups between tests</a>
</h2>
<p>
   Often, a mock-up class needs to be reused by multiple tests, or even applied for the test run as a whole.
   We will now see different ways to apply mock-ups so they are shared by a whole group of tests, as well as ways to
   define reusable mock classes.
</p>

<h3 id="beforeAfter">
   <a href="#beforeAfter">Using before/after methods</a>
</h3>
<p>
   In a given test class, we can define instance methods that will run <em>before</em> and <em>after</em> each test
   method (even when the test throws an error or exception).
   With JUnit, we use the <code class="annotation">@Before</code> and <code class="annotation">@After</code>
   annotations on one or more arbitrary instance methods of the test class.
   The same applies to the <code class="annotation">@BeforeMethod</code> and
   <code class="annotation">@AfterMethod</code> annotations when using TestNG.
</p>
<p>
   Any mock class that can be applied from inside a test method can also be applied from a "before" method, by
   instantiating a mock-up class.
   Such a mock class will remain in effect for the execution of all test methods in the test class.
   The only difference of applying mocks in a "before" method is that they also remain in effect inside "after" methods,
   if any.
</p>
<p>
   For example, if we wanted to mock the <code class="type">LoginContext</code> class with a mock-up class for a bunch
   of related tests, we would have the following methods in the test class:
</p>
<pre><code>public class MyTestClass
{
   @Before
   public void applySharedMocks()
   {
      new MockUp&lt;LoginContext>() {
         // shared mocks here...
      };
   }

   // test methods that will share the mocks applied above...
}
</code></pre>
<p>
   The example above uses JUnit, but the equivalent code for TestNG would be practically the same.
</p>
<p>
   It is also valid to extend from base test classes, which may optionally define "before" and/or "after" methods
   containing calls to the Mockups API.
</p>

<h3 id="reusableMocks">
   <a href="#reusableMocks">Reusable mock classes</a>
</h3>
<p>
   Named mock classes can be designed as concrete (and optionally <code>final</code>) classes that are then used in
   specific tests.
   When instantiated directly by test code, such mock instances can be configured through constructor arguments, fields,
   or non-mock methods.
   Alternatively, they can be designed as base classes (possibly <code>abstract</code>) to be extended by concrete mock
   classes inside specific test classes or methods.
</p>
<p>
   The example tests for this section come from JMockit's own test suite.
   They exercise the following class, partially reproduced here:
</p>
<pre><code>public final class TextFile
{
   // fields and constructors that accept a TextReader or DefaultTextReader object...
   
   public List&lt;String[]> parse()
   {
      <strong>skipHeader();</strong>

      List&lt;String[]> result = new ArrayList&lt;String[]>();

      while(true) {
         String  strLine = <strong>nextLine();</strong>

         if (strLine == null) {
            <strong>closeReader();</strong>
            break;
         }

         String[] parsedLine = strLine.split(",");
         result.add(parsedLine);
      }

      return result;
   }

   // private helper methods that call "skip(n)", "readLine()", and "close()"...
   
   public interface <strong>TextReader</strong>
   {
      long skip(long n) throws IOException;
      String readLine() throws IOException;
      void close() throws IOException;
   }

   static final class <strong>DefaultTextReader</strong> implements TextReader
   {
      DefaultTextReader(String fileName) throws FileNotFoundException { ...mocked... }
      public long skip(long n) throws IOException { ...mocked... }
      public String readLine() throws IOException { ...mocked... }
      public void close() throws IOException { ...mocked... }
   }
}
</code></pre>
<p>
   Some of the tests for the class above are as follows.
</p>
<pre><code>public final class TextFileUsingMockUpsTest
{
   // A reusable mock-up class to be applied in specific tests.
   static final class <strong>MockTextReaderConstructor</strong> extends MockUp&lt;<strong>DefaultTextReader</strong>>
   {
      @Mock(invocations = 1)
      void $init(String fileName) { assertThat(fileName, equalTo("file")); }
   }

   @Test
   public void parseTextFileUsingDefaultTextReader() throws Exception
   {
      <strong>new MockTextReaderConstructor();</strong>
      <strong>new MockTextReaderForParse&lt;DefaultTextReader>() {};</strong>

      List&lt;String[]> result = new TextFile("file", 200).parse();

      // assert result from parsing
   }

   ...
</code></pre>
<p>
   The test above uses two reusable mock classes. The first one encapsulates a mock for the single constructor of the
   <code class="type">TextFile.DefaultTextReader</code> nested class.
   Any tests exercising code in the <code class="type">TextFile</code> class that invokes this constructor will
   therefore use this mock class.
   It is applied by simply being instantiated inside the test method.
</p>
<p>
   The second mock class used by the test targets the same <code class="type">DefaultTextReader</code> class.
   As we see next, it defines mocks for a whole different set of members, which happen to be the methods called from
   the <code>TextFile#parse()</code> method.
</p>
<pre><code>...

// A reusable base mock class to be extended in specific tests.
static class <strong>MockTextReaderForParse&lt;T extends TextReader></strong> extends MockUp&lt;T>
{
   static final String[] LINES = { "line1", "another,line", null};
   int invocation;

   @Mock(invocations = 1)
   long skip(long n)
   {
      assertEquals(200, n);
      return n;
   }

   @Mock(invocations = 3)
   String readLine() throws IOException { return LINES[invocation++]; }

   @Mock(invocations = 1)
   void close() {}
}

...
</code></pre>
<p>
   The mock-up class above, like the <code class="type">mockit.MockUp&lt;T></code> class which it extends, is
   <em>generic</em>.
   In this particular case, this is necessary because the tested <code class="type">TextFile</code> class works
   with two different types for the "text reader" dependency:
   <code class="type">TextFile.TextReader</code> (an interface which client code can implement), and
   <code class="type">TextFile.DefaultTextReader</code> (an internal default implementation of the interface).
   The previous test simply used this mock class <em>as is</em>, by defining an anonymous subclass which specifies the
   type to be mocked as the <code class="type">DefaultTextReader</code> concrete class.
   The next test, on the other hand, passes a <code class="type">TextReader</code> implementation to
   <code class="type">TextFile</code>:
</p>
<pre><code>...

@Test
public void parseTextFileUsingProvidedTextReader() throws Exception
{
   TextReader textReader = <strong>new MockTextReaderForParse&lt;TextReader>() {}</strong>.getMockInstance();

   List&lt;String[]> result = new TextFile(textReader, 200).parse();

   // assert result from parsing
}

...
</code></pre>
<p>
   The interface implementation, in this case, is a mock proxy object obtained through the
   <code>MockUp&lt;T>#getMockInstance()</code> method.
</p>
<p>
   Finally, we get to a more interesting case, where the concrete mock subclass actually <em>overrides</em> some of the
   mocks inherited from the base mock class:
</p>
<pre><code>...

@Test
public void doesNotCloseTextReaderInCaseOfIOFailure() throws Exception
{
   new MockTextReaderConstructor();

   <strong>new MockTextReaderForParse&lt;DefaultTextReader>()</strong> {
      <strong>@Override</strong> @Mock
      String readLine() throws IOException { <strong>throw new IOException();</strong> }

      <strong>@Override</strong> @Mock(<strong>invocations = 0</strong>)
      void close() {}
   };

   TextFile textFile = new TextFile("file", 200);

   try {
      textFile.parse();
      fail();
   }
   catch (RuntimeException e) {
      assertTrue(e.getCause() instanceof IOException);
   }
}
</code></pre>
<p>
   The test forces an <code class="type">IOException</code> to be thrown in the first call to <code>readLine()</code>.
   (This exception will get wrapped in a <code class="type">RuntimeException</code> by the <code>parse</code> method.)
   It also specifies, through an invocation count constraint, that the <code>close()</code> method should never be
   called.
   This shows that not only the behavior of the inherited mock is overridden, but also any of the metadata specified
   through the <code class="annotation">@Mock</code> annotation.
</p>

<h2 id="widerScopes">
   <a href="#widerScopes">Mock-ups at the test class/suite level</a>
</h2>
<p>
   Often, we need to apply mock-ups for the entire scope of a test class (all of its test methods), or for the entire
   scope of a test suite (all of its test classes).
   We may also want to apply them for an entire test run, and through external configuration rather than in test code.
</p>

<h3 id="programmatic">
   <a href="#programmatic">Programmatic application of mock-ups in wider scopes</a>
</h3>
<p>
   To have a mock-up class cover the entire scope (all tests) of a given test class, we simply apply it inside a
   <code class="annotation">@BeforeClass</code> method (with JUnit or TestNG).
   To apply mock-ups over a test <em>suite</em>, we can use a TestNG <code class="annotation">@BeforeSuite</code>
   method, or a JUnit <code class="type">Suite</code> class.
   The next example shows a JUnit 4 test suite configuration with the application of mock-ups.
</p>
<pre><code>@RunWith(Suite.class)
@Suite.SuiteClasses({MyFirstTest.class, MySecondTest.class})
public final class TestSuite
{
   @BeforeClass
   public static void applyMockUps()
   {
      new LoggingMocks();

      new MockUp&lt;SomeClass>() {
         @Mock someMethod() {}
      };
   }
}
</code></pre>
<p>
   In this example, we apply the <code class="type">LoggingMocks</code> mock class and an inline mock-up class; their
   mocks will be in effect until just after the last test in the test suite has been executed.
</p>

<h3 id="systemProperty">
   <a href="#systemProperty">External application through a system property</a>
</h3>
<p>
   The <strong><code>mockups</code></strong> system property supports a comma-separated list of fully qualified mock-up
   class names.
   If specified at JVM startup time, any such class (which must extend <code class="type">MockUp&ltT></code>) will be
   automatically applied for the whole test run.
   The mocks defined in startup mock classes will remain in effect until the end of the test run, for all test classes.
   Each mock-up class will be instantiated through its no-args constructor, unless an additional value was provided
   after the class name (for example, as in "-Dmockups=my.mockups.MyMockUp=anArbitraryStringWithoutCommas"), in which
   case the mock-up class should have a constructor with one parameter of type <code class="type">String</code>.
</p>
<p>
   Note that a system property can be passed to the JVM through the standard "<code>-D</code>" command line parameter.
   Ant/Maven/etc. build scripts have their own ways of specifying system properties, so check their documentation for
   details.
</p>

<h3 id="propertiesFile">
   <a href="#propertiesFile">External application through the <code>jmockit.properties</code> file</a>
</h3>
<p>
   Mock-up classes specified in the <code>mockups</code> system property can alternatively be specified in a separate
   <strong><code>jmockit.properties</code></strong> file, which should be present at the root of the classpath.
   If there are multiple such files in the classpath (either inside jars or plain directories), all class names listed
   are added together.
   This allows the creation of reusable mock classes which can be packaged in a jar file with its own properties file;
   when added to the execution classpath of a test suite, the mock classes will be automatically applied at startup.
</p>

<h2 id="advice">
   <a href="#advice">Applying AOP-style advice</a>
</h2>
<p>
   There is one more special <code class="annotation">@Mock</code> method that can appear in a mock-up class: the
   "<code>$advice</code>" method.
   If defined, this mock method will handle executions of each and every method in the target class (or classes, when
   applying the mock-up over unspecified classes from a base type).
   Differently from regular mock methods, this one needs to have a particular signature and return type:
   <code>Object $advice(Invocation)</code>.
</p>
<p>
   For demonstration, lets say we want to measure the execution times of all methods in a given class during test
   execution, while still executing the original code of each method.
</p>
<pre><code>public final class MethodTiming extends MockUp&lt;Object>
{
   private final Map&lt;Method, Long> methodTimes = new HashMap<>();

   public MethodTiming(Class&lt;?> targetClass) { super(targetClass); }
   MethodTiming(String className) throws ClassNotFoundException { super(Class.forName(className)); }

   @Mock
   public Object $advice(Invocation invocation)
   {
      long timeBefore = System.nanoTime();

      try {
         return invocation.proceed();
      }
      finally {
         long timeAfter = System.nanoTime();
         long dt = timeAfter - timeBefore;

         Method executedMethod = invocation.getInvokedMember();
         Long dtUntilLastExecution = methodTimes.get(executedMethod);
         Long dtUntilNow = dtUntilLastExecution == null ? dt : dtUntilLastExecution + dt;
         methodTimes.put(executedMethod, dtUntilNow);
      }
   }

   @Override
   protected void onTearDown()
   {
      System.out.println("\nTotal timings for methods in " + mockedType + " (ms)");

      for (Entry&lt;Method, Long> methodAndTime : methodTimes.entrySet()) {
         Method method = methodAndTime.getKey();
         long dtNanos = methodAndTime.getValue();
         long dtMillis = dtNanos / 1000000L;
         System.out.println("\t" + method + " = " + dtMillis);
      }
   }
}
</code></pre>
<p>
   The mock-up above can be applied inside a test, in a "before" method, in a "before class" method, or even for the
   entire test run by setting "<code>-Dmockups=testUtils.MethodTiming=my.application.AppClass</code>".
   It will add up the execution times for all executions of all methods in a given class.
   As shown in the implementation of the <code>$advice</code> method, it can obtain the
   <code>java.lang.reflect.Method</code> that is being executed.
   If desired, the current invocation count and/or the invocation arguments could be obtained through similar calls to
   the <code>Invocation</code> object.
   When the mock-up is (automatically) torn down, the <code>onTearDown()</code> method gets executed, dumping measured
   timings to standard output.
</p>

<div id="bottom" class="navigation">
   <a href="Mocking.html"><img src="go-previous.png" title="Previous chapter"></a>
   <a href="CodeCoverage.html"><img src="go-next.png" title="Next chapter"></a>
   <a href="../tutorial.html"><img src="go-home.png" title="Contents"></a>
</div>
<div class="footer">
   Get help from the <a href="http://groups.google.com/group/jmockit-users">JMockit Users Group</a> or
   <a href="http://stackoverflow.com/questions/tagged/jmockit">Stack Overflow</a>.
</div>
</body>
</html>
